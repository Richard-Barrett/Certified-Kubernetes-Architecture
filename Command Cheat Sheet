1. View the pods in the default namespace with a custom view:
kubectl get pods -o custom-columns=POD:metadata.name,NODE:spec.nodeName --sort-by spec.nodeName -n kube-system

2. View the kube-scheduler YAML:
kubectl get endpoints kube-scheduler -n kube-system -o yaml

3.Create a stacked etcd topology using kubeadm:
kubeadm init --config=kubeadm-config.yaml

4. Watch as pods are created in the default namespace:
kubectl get pods -n kube-system -w

#Configuring Secure Cluster Communications
To prevent unauthorized users from modifying the cluster state, RBAC is used, defining roles and role bindings for a user. 
A service account resource is created for a pod to determine how it has control over the cluster state. 
For example, the default service account will not allow you to list the services in a namespace.

1. View the kube-config:
cat .kube/config | more

2. View the service account token:
kubectl get secrets

3. Create a new namespace named my-ns:
kubectl create ns my-ns

4. Run the kube-proxy pod in the my-ns namespace:
kubectl run test --image=chadmcrowell/kubectl-proxy -n my-ns

5. List the pods in the my-ns namespace:
kubectl get pods -n my-ns

6. Run a shell in the newly created pod:
kubectl exec -it <name-of-pod> -n my-ns sh

7. List the services in the namespace via API call:
curl localhost:8001/api/v1/namespaces/my-ns/services

8. View the token file from within a pod:
cat /var/run/secrets/kubernetes.io/serviceaccount/token

9. List the service account resources in your cluster:
kubectl get serviceaccounts

Helpful Links
https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
http://kubernetes.io/docs/admin
https://kubernetes.io/docs/concepts/cluster-administration/cluster-administration-overview/#securing-a-cluster
https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/
https://kubernetes.io/docs/reference/access-authn-authz/authorization/
https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/

# Running End-to-End Tests on Your Cluster
Running end-to-end tests ensures your application will run efficiently without having to worry about cluster health problems. 
Kubetest is a useful tool for providing end-to-end tests â€” however, it is beyond the scope of this exam. 
In this lesson, we will go through the practice of testing our ability to run deployments, run pods, expose a container, execute a command from a container, run a service, and check the overall health of our nodes and pods for conditions.

1. Run a simple nginx deployment:
kubectl run nginx --image=nginx

2. View the deployments in your cluster:
kubectl get deployments

3. View the pods in the cluster:
kubectl get pods

4. Use port forwarding to access a pod directly:
kubectl port-forward $pod_name 8081:80

5. Get a response from the nginx pod directly:
curl --head http://127.0.0.1:8081

6. View the logs from a pod:
kubectl logs $pod_name

7. Run a command directly from the container:
kubectl exec -it nginx -- nginx -v

8. Create a service by exposing port 80 of the nginx deployment:
kubectl expose deployment nginx --port 80 --type NodePort

9. List the services in your cluster:
kubectl get services

10. Get a response from the service:
curl -I localhost:$node_port

11. List the nodes' status:
kubectl get nodes

12. View detailed information about the nodes:
kubectl describe nodes

13. View detailed information about the pods:
kubectl describe pods

Helpful Links:
https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md
https://kubernetes.io/docs/getting-started-guides/ubuntu/
